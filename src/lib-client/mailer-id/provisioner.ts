/*
 Copyright (C) 2015 3NSoft Inc.
 
 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free Software
 Foundation, either version 3 of the License, or (at your option) any later
 version.
 
 This program is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 See the GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License along with
 this program. If not, see <http://www.gnu.org/licenses/>. */

import Q = require('q');
import xhrUtils = require('../xhr-utils');
import serviceLocator = require('../service-locator');
import pkl = require('../user-with-pkl-session');
import jwk = require('../../lib-common/jwkeys');
import mid = require('../../lib-common/mid-sigs-NaCl-Ed');
import certProvApi = require(
	'../../lib-common/service-api/mailer-id/provisioning');
var Uri = require('jsuri');

var DEFAULT_ASSERTION_VALIDITY = 20*60;

function getRandom(n: number): Uint8Array {
	var arr = new Uint8Array(n);
	(<any> window).crypto.getRandomValues(arr);
	return arr;
}

export interface IPromDHSKeyCalc extends pkl.IPromDHSKeyCalc {}
export interface ICalcDHSharedKey extends pkl.ICalcDHSharedKey {}

/**
 * Certificate provisioner is an object that can do all MailerId's provisioning
 * requests.
 * Provisioning is done for given user id, and is performed at service location,
 * identified by a given uri.
 */
export class MailerIdProvisioner extends pkl.ServiceUser {
	
	private userCert: jwk.SignedLoad = null;
	private provCert: jwk.SignedLoad = null;
	private midDomain: string = null;
	private rootCert: jwk.SignedLoad = null;
	private entryURI: string;
	
	/**
	 * @param userId
	 * @param uri identifies place of MailerId service.
	 */
	constructor(userId: string, serviceUri: string) {
		super(userId, {
			login: '',
			logout: ''
		});
		this.serviceURI = serviceUri;
		this.entryURI = this.serviceURI;
		Object.seal(this);
	}

	private setUrlAndDomain(): Q.Promise<void> {
		var promise = serviceLocator.mailerIdInfoAt(this.entryURI)
		.then((info) => {
			this.midDomain = (new Uri(this.serviceURI)).host();
			this.serviceURI = info.provisioning;
			this.rootCert = info.currentCert;
		});
		return promise;
	}
	
	/**
	 * @param pkey is a public key, that needs to be certified.
	 * @param duration is a desired duration of certificate's validity.
	 * Server may provide shorter duration, if asked duration is too long for its 
	 * security policy.
	 * @return a promise, resolvable to a string with certificate, generated by
	 * the MailerId server.
	 */
	private getCertificates(pkey: jwk.JsonKey, duration: number):
			Q.Promise<void> {
		var deferred = Q.defer<void>();
		var url = this.serviceURI + certProvApi.certify.URL_END;
		var xhr = xhrUtils.makeBinaryRequest('POST', url, () => {
			if (xhr.status == 200) {
				try {
					var certs: certProvApi.certify.Reply =
						this.encryptor.openJSON(new Uint8Array(xhr.response));
					if (!certs.userCert || !certs.provCert) {
						throw new Error("Certificates are missing.");
					}
					var pkeyAndId = mid.relyingParty.verifyChainAndGetUserKey(
						{ user: certs.userCert, prov: certs.provCert,
							root: this.rootCert }, this.midDomain,
						jwk.getKeyCert(certs.userCert).issuedAt+1);
					if (pkeyAndId.address !== this.userId) {
						throw new Error("Certificate is for a wrong address.");
					}
					var keyInCert = jwk.keyToJson(pkeyAndId.pkey);
					if ((keyInCert.use !== pkey.use) ||
							(keyInCert.alg !== pkey.alg) ||
							(keyInCert.kid !== pkey.kid) ||
							(keyInCert.k !== pkey.k)) {
						throw new Error("Certificate is for a wrong key.");
					}
					this.userCert = certs.userCert;
					this.provCert = certs.provCert;
					deferred.resolve();
				} catch (err) {
					xhrUtils.reject(deferred, 200,
						"Malformed reply: "+err.message);
				}
			} else {
				xhrUtils.reject(deferred, xhr);
			}
			this.encryptor.destroy();
		}, deferred, this.sessionId);
		xhr.responseType = "arraybuffer";
		
		// pack, encrypt and send them
		xhr.send(this.encryptor.packJSON( <certProvApi.certify.Request> {
			pkey: pkey,
			duration: duration
		}));
		
		var promise = deferred.promise
		.fin(() => {
			this.sessionId = null;
			this.encryptor.destroy();
			this.encryptor = null;
		});
		return promise;
	}
	
	provisionSigner(genOfDHKeyCalcPromise: IPromDHSKeyCalc,
			certDuration: number, assertDuration?: number):
			Q.Promise<mid.user.MailerIdSigner> {
		if (!assertDuration || (assertDuration < 0)) {
			assertDuration = DEFAULT_ASSERTION_VALIDITY;
		}
		var pair = mid.user.generateSigningKeyPair(getRandom);
		var promise = this.setUrlAndDomain()
		.then(() => {
			return super.login(genOfDHKeyCalcPromise);
		})
		.then(() => {
			return this.getCertificates(pair.pkey, certDuration)
			.then(() => {
				return mid.user.makeMailerIdSigner(
					pair.skey, this.userCert, this.provCert, assertDuration);
			});
		});
		return promise;
		
	}
	
	login(genOfDHKeyCalcPromise: IPromDHSKeyCalc): Q.Promise<void> {
		throw Error("This function is not used in provisioner");
	}
	logout(): Q.Promise<void> {
		throw Error("This function is not used in provisioner");
	}
	
}

Object.freeze(exports);